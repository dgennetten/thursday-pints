name: Process New Visit

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created]

jobs:
  process-visit:
    # Run for all issue events except deleted
    if: github.event_name == 'issues' && github.event.action != 'deleted'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
    
    steps:
      - name: Check if issue is a visit issue
        id: check
        run: |
          TITLE="${{ github.event.issue.title }}"
          LABELS="${{ toJSON(github.event.issue.labels) }}"
          
          echo "Issue title: $TITLE"
          echo "Issue labels: $LABELS"
          echo "Action: ${{ github.event.action }}"
          
          # Check if title contains "[Visit]" or has 'visit' label
          if echo "$TITLE" | grep -qi "\[Visit\]" || echo "$LABELS" | grep -qi '"name".*"visit"'; then
            echo "is_visit=true" >> $GITHUB_OUTPUT
            echo "This is a visit issue - proceeding"
          else
            echo "is_visit=false" >> $GITHUB_OUTPUT
            echo "This is NOT a visit issue - skipping"
            echo "Title check: $(echo "$TITLE" | grep -qi "\[Visit\]" && echo "MATCH" || echo "NO MATCH")"
            echo "Label check: $(echo "$LABELS" | grep -qi '"name".*"visit"' && echo "MATCH" || echo "NO MATCH")"
          fi
      
      - name: Comment on issue (always)
        uses: actions/github-script@v7
        with:
          script: |
            const isVisit = '${{ steps.check.outputs.is_visit }}' === 'true';
            const title = context.payload.issue.title;
            const labels = context.payload.issue.labels.map(l => l.name).join(', ');
            
            if (isVisit) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: 'üîÑ Processing visit issue...\n\n' +
                      `- **Title:** ${title}\n` +
                      `- **Labels:** ${labels || '(none)'}\n` +
                      `- **Status:** Identified as visit issue - processing will continue.`
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: '‚ö†Ô∏è This issue was not identified as a visit issue.\n\n' +
                      `- **Title:** ${title}\n` +
                      `- **Labels:** ${labels || '(none)'}\n` +
                      `- **Status:** Skipping processing.\n\n` +
                      'To process this as a visit, ensure:\n' +
                      '1. The title starts with "[Visit]" (case-insensitive), OR\n' +
                      '2. The issue has a "visit" label'
              });
            }
      
      - name: Checkout repository
        if: steps.check.outputs.is_visit == 'true'
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        if: steps.check.outputs.is_visit == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        if: steps.check.outputs.is_visit == 'true'
        run: npm ci
      
      - name: Parse issue data
        if: steps.check.outputs.is_visit == 'true'
        id: parse
        run: |
          # Use Node.js to parse GitHub issue form data more reliably
          node << 'EOF'
          const body = `${{ github.event.issue.body }}`;
          
          // GitHub issue forms use markdown format like:
          // ### Visit Date
          // 2026-02-12
          // ### Brewery Name
          // High Hops Brewery
          
          function extractField(body, fieldName) {
            const regex = new RegExp(`###\\s+${fieldName}[\\s\\S]*?\\n([\\s\\S]*?)(?=###|$)`, 'i');
            const match = body.match(regex);
            if (!match) return null;
            
            let value = match[1].trim();
            // Remove markdown formatting and clean up
            value = value.replace(/\*\*/g, '').replace(/^[-*]\s*/, '').trim();
            
            // Handle "No response", "_No response_", or empty values (case-insensitive)
            const lowerValue = value.toLowerCase();
            if (!value || lowerValue === 'no response' || lowerValue === '_no response_' || lowerValue === 'n/a') {
              return null;
            }
            
            return value;
          }
          
          let date = extractField(body, 'Visit Date');
          const brewery = extractField(body, 'Brewery Name');
          let nextBrewery = extractField(body, 'Next Brewery');
          const notes = extractField(body, 'Notes');
          
          // If date is empty, calculate next Thursday
          if (!date) {
            const d = new Date();
            const day = d.getDay();
            const diff = (4 - day + 7) % 7 || 7; // Thursday is day 4
            d.setDate(d.getDate() + diff);
            date = d.toISOString().split('T')[0];
            console.log(`Calculated next Thursday: ${date}`);
          }
          
          // Validate required fields
          if (!brewery) {
            console.error('Error: Missing required field - Brewery Name');
            process.exit(1);
          }
          
          // Check if date is less than a week old
          const visitDate = new Date(date);
          const today = new Date();
          const daysDiff = Math.floor((today - visitDate) / (1000 * 60 * 60 * 24));
          const isRecent = daysDiff < 7;
          
          // Next Brewery is required only for recent visits (less than a week old)
          if (isRecent && !nextBrewery) {
            console.error('Error: Next Brewery is required for recent visits (within the last week)');
            console.error(`Visit date: ${date} (${daysDiff} days ago)`);
            process.exit(1);
          }
          
          // For old data, nextBrewery can be null/undefined
          if (!isRecent && !nextBrewery) {
            console.log(`Note: Next Brewery not provided for historical data (${daysDiff} days old) - this is OK`);
          }
          
          // Output to GitHub Actions
          const fs = require('fs');
          const outputFile = process.env.GITHUB_OUTPUT;
          if (outputFile) {
            fs.appendFileSync(outputFile, `date=${date}\n`);
            fs.appendFileSync(outputFile, `brewery=${brewery.replace(/\n/g, ' ')}\n`);
            // Only add next_brewery if it exists
            if (nextBrewery) {
              fs.appendFileSync(outputFile, `next_brewery=${nextBrewery.replace(/\n/g, '\\n')}\n`);
            } else {
              fs.appendFileSync(outputFile, `next_brewery=\n`);
            }
            fs.appendFileSync(outputFile, `notes=${(notes || '').replace(/\n/g, ' ')}\n`);
          } else {
            // Fallback for testing
            console.log(`::set-output name=date::${date}`);
            console.log(`::set-output name=brewery::${brewery}`);
            console.log(`::set-output name=next_brewery::${nextBrewery}`);
            console.log(`::set-output name=notes::${notes || ''}`);
          }
          
          console.log('Parsed values:');
          console.log(`  Date: ${date}`);
          console.log(`  Brewery: ${brewery}`);
          console.log(`  Next Brewery: ${nextBrewery}`);
          console.log(`  Notes: ${notes || '(none)'}`);
          EOF
        continue-on-error: false
      
      - name: Update data.json
        if: steps.check.outputs.is_visit == 'true'
        run: |
          echo "Updating data.json with new visit..."
          echo "Date: ${{ steps.parse.outputs.date }}"
          echo "Brewery: ${{ steps.parse.outputs.brewery }}"
          
          # Save current file size for comparison
          if [ -f "public/data.json" ]; then
            OLD_SIZE=$(wc -c < public/data.json)
            echo "Current data.json size: $OLD_SIZE bytes"
          fi
          
          # Build command with optional next-brewery
          CMD="node scripts/add-visit.js --date \"${{ steps.parse.outputs.date }}\" --brewery \"${{ steps.parse.outputs.brewery }}\""
          if [ -n "${{ steps.parse.outputs.next_brewery }}" ]; then
            CMD="$CMD --next-brewery \"${{ steps.parse.outputs.next_brewery }}\""
          fi
          if [ -n "${{ steps.parse.outputs.notes }}" ]; then
            CMD="$CMD --notes \"${{ steps.parse.outputs.notes }}\""
          fi
          eval $CMD
          
          # Check new file size
          if [ -f "public/data.json" ]; then
            NEW_SIZE=$(wc -c < public/data.json)
            echo "New data.json size: $NEW_SIZE bytes"
            if [ "$OLD_SIZE" != "$NEW_SIZE" ]; then
              echo "‚úÖ File size changed - visit was added/updated"
            else
              echo "‚ö†Ô∏è  File size unchanged - visit may have already existed"
            fi
          fi
      
      - name: Build application
        if: steps.check.outputs.is_visit == 'true'
        run: npm run build
      
      - name: Verify data.json contains new visit
        if: steps.check.outputs.is_visit == 'true'
        run: |
          echo "Verifying that dist/data.json contains the new visit..."
          if [ -f "dist/data.json" ]; then
            if grep -q "\"date\": \"${{ steps.parse.outputs.date }}\"" dist/data.json && \
               grep -q "\"breweryName\": \"${{ steps.parse.outputs.brewery }}\"" dist/data.json; then
              echo "‚úÖ Verified: Visit found in dist/data.json"
              # Show the relevant entry
              node -e "
                const data = require('./dist/data.json');
                const visit = data.find(v => v.date === '${{ steps.parse.outputs.date }}');
                console.log('Visit entry:', JSON.stringify(visit, null, 2));
              "
            else
              echo "‚ùå ERROR: Visit NOT found in dist/data.json!"
              echo "Looking for date: ${{ steps.parse.outputs.date }}"
              echo "Looking for brewery: ${{ steps.parse.outputs.brewery }}"
              exit 1
            fi
          else
            echo "‚ùå ERROR: dist/data.json does not exist!"
            exit 1
          fi
      
      - name: Show file diff
        if: steps.check.outputs.is_visit == 'true'
        run: |
          echo "Checking for changes in data.json..."
          git add public/data.json
          if ! git diff --staged --quiet; then
            echo "Changes detected:"
            git diff --staged public/data.json | head -50
          else
            echo "No git changes detected - file content is the same"
            echo "This can happen if the visit already exists with identical data"
            echo "Showing current entry for this date:"
            node -e "
              const data = require('./public/data.json');
              const visit = data.find(v => v.date === '${{ steps.parse.outputs.date }}');
              console.log(JSON.stringify(visit, null, 2));
            "
          fi
      
      - name: Commit changes
        if: steps.check.outputs.is_visit == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add public/data.json
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit - visit may already exist with same data"
            echo "File will still be deployed to ensure server is in sync"
          else
            echo "Committing changes..."
            git commit -m "Add visit: ${{ steps.parse.outputs.date }} - ${{ steps.parse.outputs.brewery }}"
            git push
            echo "Changes committed and pushed successfully"
          fi
      
      - name: Verify data.json before deploy
        if: steps.check.outputs.is_visit == 'true'
        run: |
          echo "Verifying dist/data.json before FTP deploy..."
          echo "File size: $(wc -c < dist/data.json) bytes"
          echo "File hash (MD5): $(md5sum dist/data.json | cut -d' ' -f1)"
          echo "First few lines:"
          head -5 dist/data.json
      
      - name: Deploy to Dreamhost via FTP
        if: steps.check.outputs.is_visit == 'true'
        uses: SamKirkland/FTP-Deploy-Action@4.3.0
        id: ftp-deploy
        with:
          server: ${{ secrets.FTP_SERVER }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          server-dir: /public_html/
          local-dir: ./dist/
          dangerous-clean-slate: false
          dry-run: false
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            **/.DS_Store
          log-level: verbose
          state-name: .ftp-deploy-sync-state.json
      
      - name: Install FTP client
        if: steps.check.outputs.is_visit == 'true'
        run: npm install basic-ftp --no-save
      
      - name: Force upload data.json via FTP
        if: steps.check.outputs.is_visit == 'true'
        run: |
          echo "Force uploading data.json to ensure it's updated on server..."
          node << 'EOF'
          const ftp = require('basic-ftp');
          const fs = require('fs');
          const path = require('path');
          
          async function uploadFile() {
            const client = new ftp.Client();
            try {
              await client.access({
                host: process.env.FTP_SERVER,
                user: process.env.FTP_USERNAME,
                password: process.env.FTP_PASSWORD,
                secure: false
              });
              
              console.log('Connected to FTP server');
              
              // Change to public_html directory
              await client.cd('/public_html');
              console.log('Changed to /public_html directory');
              
              // Upload data.json
              const localFile = path.join(process.cwd(), 'dist/data.json');
              console.log(`Uploading ${localFile} to /public_html/data.json`);
              
              await client.uploadFrom(localFile, 'data.json');
              console.log('‚úÖ data.json uploaded successfully');
              
              // Verify file size
              const stats = await client.size('data.json');
              const localStats = fs.statSync(localFile);
              console.log(`Server file size: ${stats} bytes`);
              console.log(`Local file size: ${localStats.size} bytes`);
              
              if (stats === localStats.size) {
                console.log('‚úÖ File sizes match - upload verified');
              } else {
                console.log('‚ö†Ô∏è  File sizes do not match - upload may have failed');
              }
              
            } catch (error) {
              console.error('‚ùå FTP upload error:', error.message);
              process.exit(1);
            } finally {
              client.close();
            }
          }
          
          uploadFile();
          EOF
        env:
          FTP_SERVER: ${{ secrets.FTP_SERVER }}
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
      
      - name: Verify server file after upload
        if: steps.check.outputs.is_visit == 'true'
        run: |
          echo "Verifying file was actually updated on server..."
          node << 'EOF'
          const ftp = require('basic-ftp');
          const fs = require('fs');
          const path = require('path');
          
          async function verifyFile() {
            const client = new ftp.Client();
            try {
              await client.access({
                host: process.env.FTP_SERVER,
                user: process.env.FTP_USERNAME,
                password: process.env.FTP_PASSWORD,
                secure: false
              });
              
              await client.cd('/public_html');
              
              // Download the file from server
              const tempFile = path.join(process.cwd(), 'server-data.json');
              await client.downloadTo(tempFile, 'data.json');
              
              // Compare with local file
              const localFile = path.join(process.cwd(), 'dist/data.json');
              const localContent = fs.readFileSync(localFile, 'utf8');
              const serverContent = fs.readFileSync(tempFile, 'utf8');
              
              const localData = JSON.parse(localContent);
              const serverData = JSON.parse(serverContent);
              
              // Find the visit we just added
              const visitDate = '${{ steps.parse.outputs.date }}';
              const localVisit = localData.find(v => v.date === visitDate);
              const serverVisit = serverData.find(v => v.date === visitDate);
              
              console.log('Local visit:', JSON.stringify(localVisit, null, 2));
              console.log('Server visit:', JSON.stringify(serverVisit, null, 2));
              
              if (JSON.stringify(localVisit) === JSON.stringify(serverVisit)) {
                console.log('‚úÖ Server file matches local file - upload successful!');
              } else {
                console.log('‚ùå Server file does NOT match local file!');
                console.log('This suggests the file was not properly uploaded or was overwritten.');
                process.exit(1);
              }
              
              // Clean up
              fs.unlinkSync(tempFile);
              
            } catch (error) {
              console.error('‚ùå Verification error:', error.message);
              process.exit(1);
            } finally {
              client.close();
            }
          }
          
          verifyFile();
          EOF
        env:
          FTP_SERVER: ${{ secrets.FTP_SERVER }}
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
      
      - name: Verify deployment
        if: steps.check.outputs.is_visit == 'true'
        run: |
          echo "Deployment completed. Please verify the file on the server."
          echo "Expected file hash (MD5): $(md5sum dist/data.json | cut -d' ' -f1)"
          echo "File size: $(wc -c < dist/data.json) bytes"
          echo ""
          echo "To verify on server, check: https://your-site.com/data.json"
          echo "The file should contain the visit for: ${{ steps.parse.outputs.date }}"
      
      - name: Comment on issue with results
        if: steps.check.outputs.is_visit == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const date = '${{ steps.parse.outputs.date }}';
            const brewery = '${{ steps.parse.outputs.brewery }}';
            const nextBrewery = '${{ steps.parse.outputs.next_brewery }}';
            const notes = '${{ steps.parse.outputs.notes }}';
            
            let body = '‚úÖ Visit added and deployed successfully!\n\n';
            body += `- **Date:** ${date}\n`;
            body += `- **Brewery:** ${brewery}\n`;
            if (nextBrewery && nextBrewery.trim() !== '') {
              body += `- **Next Brewery:** ${nextBrewery}\n`;
            } else {
              body += '- **Next Brewery:** (not provided for historical data)\n';
            }
            if (notes && notes.trim() !== '') {
              body += `- **Notes:** ${notes}\n`;
            }
            body += '\nüí° **Note:** If you do not see the changes on the website, try a hard refresh:\n';
            body += '- **Windows/Linux:** Ctrl + F5 or Ctrl + Shift + R\n';
            body += '- **Mac:** Cmd + Shift + R\n';
            body += 'The app uses cache-busting, but your browser may have cached the old file.';
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
            
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });
        continue-on-error: true
      
      - name: Handle errors
        if: failure() && steps.check.outputs.is_visit == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '‚ùå Error processing visit. Please check the workflow logs for details.'
            })
